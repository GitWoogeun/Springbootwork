#┌─────────────────────────────────────────────────────────────────────────────────
#│ 스프링부트 작동 원리
#└─────────────────────────────────────────────────────────────────────────────────

1. 제일 먼저 톰캣이 실행이 되면

2. 필터들이 다 메모리에 올라간다. 
=> 권한 필터, 인증 필터, 한글 인코딩 필터, 등등

3. Dispatcher가 메모리에 올라온다.
=> 주소를 사용자들이 요청을 할거잖아요
   /admin, /user 등등 요청을 할 때 이 주소를 Dispatcher가 확인을 해서 
   적절한 Controller에게 요청을 할거거든요. 

   중간에 어떤 주소가 들어왔는지 확인하고 그 주소가 맞는 Controller에게 요청을 해주는게
   Dispatcher의 역할이에요~

4. Controller 
=> Controller가 메모리에 뜨고 Service가 메모리에 뜨고, JPARepository가 메모리 뜨고
   영속성 컨텍스트가 메모리에 떠요, 애들은 요청 시 마다 메모리에 떠요
   
   사용자 한명이 요청을 하면 Controller, Service, JPARepository, 영속성 하나가 떠요
   그런 다음에 다른 사용자가 요청을하면 기존에 떠 있는 애들을 재사용하는게 아니라
   Thread(스레드) 하나 추가해서 요청을 들어올 때마다 스레드가 만들어지면서

   위 4개가 지속적으로 만들어지게 되어있어요. 하나로 유지되는게 아니라

5. 톰캣이 실행이 되면 필터와 Dispatcher는 메모리에 올라오지만
   Controller , Service, JPARepository, 영속성컨텍스트는 일단 대기..

   위 4개는 사용자의 Request요청이 있을 때 메모리에 떠요!
   => 사용자의 요청이 있을 때 마다 스레드가 하나 만들어지면서 4개의 메모리가 떠요

6. 데이터 소스는 톰캣이 시작되면 사용자가 요청을 하지 않아도 미리 떠 있습니다. 
   데이터 소스는 데이터베이스와 직접적인 연결이 되어 있다.

7. ViewResolve , 인터셉터 이 두개도 톰캣이 실행되면 메모리에 뜬다.

#┌─────────────────────────────────────────────────────────────────────────────────
#│ Controller와 RestController
#└─────────────────────────────────────────────────────────────────────────────────
Controller가 RestController 라면 :
Data를 응답하는 Controller 이고
Controller가 그냥 Controller 라면 : 
HTML 페이지를 리턴해주는 Controller이다.
그냥 페이지를 리턴하는 그냥 Controller가 실행이 된다면 
그 때는 ViewResolve가 작동을해요 
ViewResolve가 뭐냐면 페이지를 만들어서 응답을 해줍니다.
Controller에서 화면을 보여달라는 요청이 들어왔을 시 ViewResolve가 작동을 합니다.
Controller에 메인페이지 요청이 들어왔다면 ViewResolve가 메인페이지를 찾기 위해
JSP 페이지를 HTML로 만들어서 사용자한테 응답을 해준다.


만약 RestController면 ViewResolve가 작동을 하지 않고 해당 데이터를 리턴을 해줍니다.
RestController에서 리턴할 때 메인페이지를 찾는게 아니라 
요청이 메인페이지라면 메인페이지를 호출 했다는 message 자체를 응답을해줘요
요청한 사용자에게 

#┌─────────────────────────────────────────────────────────────────────────────────
#│ 인터셉터는 무엇일까
#└─────────────────────────────────────────────────────────────────────────────────
=> 만약에 1번 유저의 개인정보 확인 요청이라면
   인터셉터가 하는일은 개인정보 확인 요청 함수가 실행 되기 직전에
   지금 들어온 요청이 해당 사용자가 Session에 있는지 확인을해서 
   Session에 유저라는 오브젝트가 1번 유저인지 확인을 하겠죠
   확인을해서 같은 정보를 가지고 있다면 요청한 정보를 보여주고 
   1번유저가 아니라면 유저의 정보를 보여주지 않는다.
   
   이러한 권한체크를 인터셉터에서 진행한다.
   권한이 있으면 인터셉터에서 데이터를 응답해준다.


전체적으로
톰캣 시작 => 필터와 디스패처가 메모리에 떠요
=> 데이터소스와 인터셉터가 메모리에 뜨고,
사용자가 Request 요청을 하면 Controller가 하나 생성하고 메모리에 뜨면서
Service한테 Body 데이터를 넘겨요 ( username과 password를 )
그래서 Service한테 시키죠 username과 password를 가지고 데이터베이스에 
있는 정보인지 아닌지 확인을하기위해서 그렇기 위해 JPARepository한테 던져요

그렇다면 JpaRepository에서 영속성컨텍스트에게 데이터가 있는지 없는지 확인 요청을하고
들고 있다면 JPARepository가 영속성 컨텍스트가 가지고 있는 정보를 가져오고
없다면 영속성컨텍스트한테 DB한테 질의를 요청 시켜서
SELECT해서 정보가져온걸 영속성컨텍스트한테 저장하고 가져온다.

데이터베이스에 NULL이면 권한이 없다고 정상적인 응답페이지를 반환하지 않는다.;


#┌─────────────────────────────────────────────────────────────────────────────────
#│ 회원가입 요청이 있다고 치자
#└─────────────────────────────────────────────────────────────────────────────────

회원가입 요청이라는건 insert 데이터베이스에 값을 넣어준다는거잖아요

DisPatcher가 해당 컨트롤러에게 회원가입 Body 데이터를 가지고 서비스에게 요청을 하겠죠
Service가 Controller에게 온 요청을 받으면 자동으로 Transaction이 시작이 되여
Service단에서 Transaction이 시작되지만 Controller부터 JDBC가 연결이 되어요.

데이터베이스에 세션이 만들어진다고 보면되요
서비스에서 Transaction이 시작이되고 JPARepository한테 DB에 Insert 해줘 요청을 한다.
영속성 컨텍스트에 최초 Insert니까 바로 데이터베이스에 질의하겟죠 Insert 해달라고 

그러면 DB에 실제로 Insert가 될거에요 

정상적으로 회원가입이 되었다면 
DB에서 => Repository => Service 서비스에서 (트랜잭션이 종료)
Controller가 ViewResolve에게 데이터 전달해서 화면에서 제공

서비스 단에서는 Transaction을 관리할수 있다.
Transaction이 종료되기 전까지는 저장된 데이터는 메모리에만 존재하고
Transaction이 정상적으로 종료될 때 DB에 실제로 커밋이 된다. (영구적 저장)

#┌─────────────────────────────────────────────────────────────────────────────────
#│ 송금요청 예제 
#└─────────────────────────────────────────────────────────────────────────────────

A가 B에게 500만원을 송금을 하는 요청이 있다 치자.
Controller는 A의 유저 정보 , B 유저정보 500만원 데이터를 서비스한테 넘긴다.
서비스는 A 업데이트, A => B에게 500만원 송금  A의 돈 UPDATE 시켜야함
서비스 => JPARepository 한테 A의 정보를 업데이트해줘 


[영속성 컨텍스트에 A의 정보가 있다면]
영속성 컨텍스트에 A 오브젝트의 데이터가 있다면 DB에 가지고 영속성 컨텍스트의
A의 정보만 업데이트하고 끝냄
영속성 컨텍스트 => JPARepository => Service 에서 끝나는 순간 트랜잭션이 종료가 되니까
트랜잭션이 정상적으로 종료가 되었다면 
영속성 컨텍스트에 있는 A의 업데이트 된 정보를 DB에 flush를 합니다.
flush가 되었다면 이 때 자동으로 DB에 flush된 데이터가 커밋이 됩니다. (실제 데이터베이스 반영)


[영속성 컨텍스트에 A의 정보가 없다면]
데이터베이스에 실제로 UPDATE 요청을 한다.
UPDATE 요청을해서 응답이 와서 서비스 쪽에서 정상으로 떨어졌다고 하더라도
Controller에게 전달해주면 안된다.
왜냐하면 A의 정보만 업데이트할게 아니라 B의 정보도 업데이트를 해야하기 때문에
B의 유저에게 500만원을 플러스 해줘야하니까

이때 다시 JPA Repository에게 UPDATE 요청을 해야해요. B의 정보를 UPDATE를 해달라고
업데이트 요청을 2번 하는것 ( A , B )
영속성 컨텍스트에 B의 정보가 없다면 똑같이 DB에 실제로 Insert 요청을 할거고,
정상적으로 응답이 되면 JPARepository한테 응답이 될꺼고 그런 다음에 서비스로 가서 
두개의 업데이트가 정상적으로 끝났잖아요?
그러면 트랜잭션이 종료가 될꺼고, 이 때 자동으로 DB에 저장된 데이터가 커밋이될꺼에요

근데 만약에

A가 정상적으로 끝나고, B가 정상적으로 끝나지 않았을 시
그러면 트랜잭션이 종료되기 전 서비스단에서 처리를 해줘야해요.
서비스에서 A가 정상적으로 끝나고 B가 실패 했을 시 
RollBack 처리를 해줘야해요. 이런 처리를 서비스에서 하면 됩니다.

그렇기 때문에 트랜잭션이 정상적으로 종료가 될 시 커밋 (DB 영구 저장)
트랜잭션이 정상적으로 종료가 되지 않을 시 ROLL-BACK 
이런 처리를 서비스에서 하면 됩니다.;

#┌─────────────────────────────────────────────────────────────────────────────────
#│ 서비스의 역할
#└─────────────────────────────────────────────────────────────────────────────────
서비스는 여러가지의 데이터베이스의 요청과 응답을 받는 상황이 
무수히 많이 일어나는 하나의 패키지라고 생각하면 됩니다.

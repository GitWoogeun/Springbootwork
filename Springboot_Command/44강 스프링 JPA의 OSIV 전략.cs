
# 스프링 JPA의 OSIV 전략
[ 스프링부트의 전통적인 트랜잭션방식의 문제점 해결 ]

개선 방법
┌───────────────┐    ┌─────────────┐    ┌───────────────┐    ┌─────────────┐  ┌───────┐
│ 사용자 Request│  => │ Controller │  => │   Service    │  => │ repository │ =>│  DB  │   
│   ( 요청 )    │  <= │   ( 분기 ) │  <= │ (   송금  )   │ <= │ (CRUD 실행) │ <=│      │ 
└───────────────┘    └─────────────┘    └───────────────┘    └─────────────┘  └───────┘

첫번째로 : REQUEST를하면 JDBC Connection이 연결이되겠죠
          연결되었다는건 CRUD 구현이 가능하다는 것

두번째로 : 트랜잭션이 열려요

세번째로 : 영속성 컨텍스트가 시작
           사용자가 요청(request)를 딱 하면
           [ JDBC Connection이 시작 ] =>[ 트랜잭션이 시작 ] => [ 영속성컨텍스트 시작 ]
           그래서 Controller가 분기를 하고 Service가 송금을하면 repository가 실행이되고
           영속성 컨텍스트에 계좌 객체가 만들어지겠죠? 계좌 객체가
           홍길동 계좌, 장보고 계좌 생성
           응답이되면서 서비스에서 받죠
           객체에 대한 값을 업데이트를 수행을 하고 영속성에 있는 객체 값을 변경
           Controller에 들어와서 응답을 하기 직전에
           JDBC Connection을 닫아버리고 (종료)
           Transaction (종료) => 커밋
           변경감지를해서 실제 이때 업데이트가 수행이 됩니다.
           마지막으로 영속성 컨텍스트가 종료가 되어요.

           서비스가 종료가 될때 영속성 컨텍스트를 종료시켜도 된다.
           데이터베이스 Connection 시점이 줄어들고 
           트랜잭션의 범위도 종료되고
           영속성 컨텍스트도 빨리 종료되니까 데이터베이스 부하가 적어져요
           훨씬 더 짧아진다.

           서비스 종료 시점에서 트랜잭션을 종료시켜서 커밋이 되게끔 합니다.

네번째로 : JDBC Connection도 Controller에서 할 필요가 없다 ( Transaction )도 포함
          영속성컨텍스트만 Controller에서 실행이되고
          Controller에서 서비스 호출할때 JDBC Connection이 시작되고
          트랜잭션이 시작되어요
          이렇게하면 JDBC Connection과 트랜잭션이 시간이 줄어들겠죠
          서비스 들어가기 직전 , 서비스가 종료될때 종료될테니까
          데이터베이스 부하가 줄어들어요

다섯번째로 : 이렇게 되면 문제가 뭐냐면 테이블이

# MySQL의 기본 격리 수준

MySQL은 InnoDB의 Storyge 엔진을 사용 합니다.

Repeatable read 이상 방식을 사용해요 사용하면 부정합 발생하지 않아요!


[ 부정합이 발생하지 않는다는건 ] 
내가 지금 SELECT를 했을 때
내가 하나의 트랜잭션이 실행되고 나서
SELECT를 했을 때 결과가 트랜잭션이 종료되는 시점까지 
동일한것들을 SELECT할때마다 계속 동일한 값이 나와야 해요

근데 만약에 한번이라도 다른 결과가 나온다면 이걸 부정합이라고 해요

[ PHANTOM READ라는게 뭐냐면 == 부정합 ]
내가 하나의 트랜잭션을 시작하고 SELECT를 했는데.
계속 동일한 값이 나오다가 결과가 없어진다면 
이걸 PHANTOM READ라고 한다.


트랜잭션 12번 시작 
트랜잭션 11번 보다 늦게 시작
11번이 먼저 실행 함 SELECT를 해봤더니 임꺽정이 나옴
12번이 업데이트문을 날림 임꺽정을 장보고로 변경
11번 입장에서는 SELECT를 해도 계속 임꺽정이 나와요
왜냐면 아직 12번 트랜잭션이 커밋이 되지 않았기 때문에
계속 11번이 SELECT를 해서 임꺽정이 나오다가
12번이 커밋을 하는 시점부터 데이터가 변경이 된다면
READ COMMIT은 Transaction이 끝나지 않았음에도 변경된 데이터의 결과값이 호출이 됩니다.
[ READ COMMIT == 부정합이 발생할수도 있음 ]
# 이유 : READ COMMIT은 커밋만 되면 무조건 커밋된 결과를 보게 되어있단 말이에요

하지만 Repeatable은 11번 트랜잭션은 12번이 먼저 Update문을 수행한 커밋이 이뤄진다고 하더라도
11번 트랜잭션이 아직 트랜잭션이 종료가 되지 않았기 때문에 변경되지 않은 값을 호출해요.
[ Repeatable == 부정합이 발생하지 않음 ]

트랜잭션은 한번 실행이 되었을 때 자기 보다 낮은 undo 로그만 보고 select를 합니다.
트랜잭션 10번이 임꺽정을 넣어 놓았으면 트랜잭션 11번은 트랜잭션 10번을 보고 select를 하고
트랜잭션 12번은 보지 않아요~ 이게
[ Repeatable READ ] 입니다. 

자기 트랜잭션보다 낮은 undo 로그를 보고 값이 들어가기 때문에
Transaction을 시작하지 않고 SELECT를 한다면 데이터가 변경된 순간
기존 동일한 데이터가 나오지 않고 변경된 데이터가 나와요.

하지만 트랜잭션이 시작을하면 트랜잭션을 시작한 그 안에서 동일한 데이터를 볼수있게 보장이 되거든요
그래서 나중에 스프링에서 어떻게 쓰냐면 원래는 보통 CRUD가 있는데
DELETE , UPDATE, INSERT는 데이터가 변경이 되기 때문에 TRANSACTION을 타게 하기 위해서
@Transaction 어노테이션을 붙여요.

근데 SELECT를 할때는 @Transaction을 붙이지 않지만 
하지만 나중에 select를 할때도 정합성을 위해서 내가 SELECT하는 기간동안은
동일한 데이터를 보는 정합성을 위해서 꼭 Transaction 붙여서 
SELECT할때도 트랜잭션을 타게 해줘야 데이터의 정합성을 유지할수 있습니다.


쉽게 정리 하면
스프링에서 SELECT 할때도 @Transaction 어노테이션을 붙인다 왜?
데이터의 정합성을 유지하기 위해서
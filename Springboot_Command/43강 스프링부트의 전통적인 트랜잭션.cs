
# 스프링부트의 트랜잭션
- 세션의 시작은 서블릿이 시작되는 시점 부터 ~ ( 세션은 영속성 컨텍스트를 포함 )
- 트랜잭션의 시작은 서비스 레이어부터, JDBC 커넥션도 이 시점부터.
- 트랜잭션의 종료는 서비스 계층에서 종료, JDBC 커넥션도 이 시점 부터 종료
- 세션은 컨트롤러 영역까지 끌고 가기 때문에 영속성이 보장되어 SELECT가 가능해지고
  lazy-loading이 가능해진다.

스프링을 시작을 하면 
첫번째로 톰캣이 시작이 되겠죠 - WAS서버 작동
두번째로 web.xml이 읽어질것이고
세번째로 context.xml -> DB연결 테스트;

[ SpringBoot의 영속성컨텍스트 트랜잭션의 순서 원리 ]
1. 데이터베이스 연결 ( JDBC Connection : CRUD 가능 );
2. 트랜잭션이 시작 ( 쿼리 하나하나 시작 );
3. Controller에서 요청을 분기해 그 요청에 맞는 서비스 호출;
4. 해당 요청에 맞는 테이블을 조회(SELECT);
5. 결과를 영속성 컨텍스트에 객체화 시켜서 저장 ( 1차 캐시 지역 );
6. Repository => Service => Controller를 타서 화면에 제공
7. 트랜잭션이 종료 되면 자동으로 영속성컨텍스트 1차 캐시에 있는 데이터를
   flash를 통해서 데이터베이스에 값을 저장


"스프링부트의 전통적인 트랜잭션 방식"
=> 스프링부트는 영속성 컨텍스트를 이용한 트랜잭션 처리 방식을 제공 합니다.

"스프링부트의 영속성 컨텍스트를 이용한 트랜잭션 처리 방식"
=> 개발자가 직접 Connection을 다루지 않고, 영속성 컨텍스트를 통해 데이터베이스와 통신 합니다.
   이 방식에서는 트랜잭션을 시작하고 종료하는 코드를 작성하지 않아도 되며, 영속성 컨텍스트가
   트랜잭션의 범위 안에서 모든 변경사항을 자동으로 처리합니다.
   또한 스프링부트가 제공하는 트랜잭션 관리자를 이용하면 복잡한 트랜잭션처리도 간단하게 처리할 수 있습니다.
   이러한 방식은 간편하고 안정적이지만, 대용량 데이터 처리에는 적합하지 않을 수 있습니다.
   이 경우 JDBC를 이용한 전통적인 트랜잭션 처리방식을 선택할 수 있습니다.

"영속성 컨텍스트와 데이터베이스의 통신 방법"
[ 첫번째 ]
영속성 컨텍스트는 내부 1차캐시와 데이터베이스의 동기화 방법 입니다.
영속성 컨텍스트는 엔티티를 조회할 때 데이터베이스에 직접 접근하지 않고 
내부 1차캐시에 저장합니다. 이후에 같은 엔티티를 조회할 경우에는 내부 1차캐시에서 
바로 조회하여 데이터베이스와의 통신을 최소화합니다. 엔티티를 저장하거나 수정할 때도 
먼저 내부 1차캐시에 업데이트를 수행한 후에, 
[ 트랜잭션이 커밋되는 시점에 영속성컨텍스트에서 flash 하여 데이터베이스와 동기화 ] 됩니다.

[ 두번째 ] 
데이터베이스와의 통신 방법입니다. 스프링부트는 기본적으로 JPA를 이용하여 데이터베이스와 통신
JPA는 데이터베이스 벤더의 종류와 상관없이 표준화된 인터페이스를 제공하므로 
데이터베이스 종류에 상관없이 일관된 방식으로 개발할 수 있습니다. 
JPA는 JDBC보다 추상화 수준이 높기 때문에 개발자가 직접 SQL을 작성할 필요가 없고 
객체지향적인 방식으로 데이터를 다룰 수 있습니다. 따라서 개발 생산성을 높일 수 있습니다.


[ 영속성 컨텍스트와 데이터베이스의 통신 예시 소스 ];

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    // Insert 쿼리
    @Transactional
    public User createUser(UserDto userDto) {
        User user = new User(userDto.getName(), userDto.getEmail());
        userRepository.save(user);
        return user;
    }

    // Select 쿼리 
    @Transactional(readOnly = true)
    public User getUserById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}

위의 예시 코드에서 'UserRepository'는 Spring Data JPA의 인터페이스 이며
'save()' 메서드와 'findById()' 메서드를 제공합니다.
'createUser()' 메서드에서는 'save()' 메서드를 호출하여 새로운 사용자를 데이터베이스에 저장합니다.

'getUserById()' 메서드에서는 'findById()' 메서드를 호출하여 특정 사용자를
데이터베이스에서 가져옵니다. 이때 @Transactional(readOnly = true);
어노테이션을 사용하여 트랜잭션을 읽기 전용으로 설정하였습니다.
이는 해당 메서드에서는 영속성 컨텍스트를 읽기 전용으로 사용하게 하여 최적화된
데이터베이스 쿼리를 수행하도록 합니다.

위의 예시 코드에서 '@Transactional' 어노테이션이 사용되었습니다.
이는 해당 메서드가 트랜잭션 내에서 실행되어야 함을 나타내며 메서드의 실행결과가 
데이터베이스에 영구적으로 저장하거나 영구적으로 수정되어야 함을 나타냅니다.
따라서 트랜잭션 내에서 실행되는 모든 코드는 영속성 컨텍스트와 데이터베이스의 통신을
통해 데이터를 관리하게 됩니다.


# 스프링부트의 트랜잭션
- 세션의 시작은 서블릿이 시작되는 시점 부터 ~ ( 세션은 영속성 컨텍스트를 포함 )
- 트랜잭션의 시작은 서비스 레이어부터, JDBC 커넥션도 이 시점부터.
- 트랜잭션의 종료는 서비스 계층에서 종료, JDBC 커넥션도 이 시점 부터 종료
- 세션은 컨트롤러 영역까지 끌고 가기 때문에 영속성이 보장되어 SELECT가 가능해지고
  lazy-loading이 가능해진다.


스프링을 시작을 하면 
첫번째로 톰캣이 시작이 되겠죠 - 서버 작동
두번째로 web.xml이 읽어질것이고
세번째로 context.xml -> DB연결 테스트

첫번째로 request 요청을하면 송금 요청을 한다치면
{
    홍길동이 장보고에게 10,000원을 송금하는 요청을 했다.
    web.xml을 거쳐서 Controller거쳐서 필터를 거치는 이 시점에 
    
    (1). 데이터베이스 연결 세션이 만들어 진다. (생성) JDBC가 Connection이 됐다는거에요! (CRUD가능)
    (2). 트랜잭션이 시작이 된다.
    (3). 요청을 분기할수있는 Controller로 들어와서 그 요청에 맞는 서비스 호출
    (4). 일단 계좌 테이블을 SELECT를 (홍길동과 장보고)해요
    (5). 영속성 컨텍스트에 객체화를 시켜서 딱 만든다. ( 1차 캐시 지역 )
    (6). SELECT를 했으니까 그 다음 로직이 SELECT된 객체를 
         repository => Service => Controller를 타서 값을 변경해요.
         홍길동 계좌에는 2만원에서 1만원을 뺀 1만원을 저장
         장보고 계좌에는 2만원에서 1만원을 더한 3만원을 저장 (영속성 컨텍스트 안에 있는 값만 변경)
    (7). 변경이 다 끝나면 Controller로 돌아와서 RestController는 응답을 데이터를 응답을 해줄것이고
         JSON으로 만약 Controller라면 HTML을 리턴을 해줄것 (송금이 완료되었습니다.)
         메인 페이지로 돌아가는 화면을 보여주겠죠.
    (8). 트랜잭션을 종료 시켜버린다. 자동으로 영속성 컨텍스트에 있는 객체 2개(계좌)가
         값이 변경되어있잖아요? 그러면 데이터베이스한테 변경 감지를 해서 
         flash를해서 영속성 컨텍스트에 있는 변경된 값을 DB에 짚어 넣는다.
        그런 다음에 response가 되는거거든요.
        이때 하나 일을 더해요 JDBC Connection을 끊어버리면 되겠죠
        그럼 DB연결 세션이 종료돼요. 같이 
        이렇게 돌아가는 기본 로직입니다.
}

다음시간에 이 방식이 문제점이 있는데 이 문제점에 대해서 말하고
문제 해결 방식을 알려주겠습니다.